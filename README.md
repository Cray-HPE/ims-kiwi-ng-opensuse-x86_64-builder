#  ims-kiwi-ng-opensuse-x86_64-builder
An openSUSE x86-64-based Docker image containing the kiwi-ng tool for image 
building. This is part of the CMS Image Management and Image Customization
toolset for Shasta-based systems.

##IMS Workflow

This container is part of the IMS workflow used to create new images from a kiwi
recipe description. Upon successful building of a recipe, the follow on containers
are expected to package and upload build artifacts to ARS.

Upon failure to build a recipe, this container sets a flag used by the follow on
containers to know that the build failed. 

PARAMETER_FILE_BUILD_FAILED=$IMAGE_ROOT_PARENT/build_failed

In the case of a failure, follow on containers have the option of enabling a SSH
shell where the administrator can access the failed image root in order to determine
the nature of the failure and how to resolve. 

## Getting Started
### Prerequisites
To build and use the ims-kiwi-ng-opensuse-x86_64-builder Docker image, you will
need Docker installed on your system, and a viable Kiwi image recipe. See the
[Kiwi Docs](https://opensource.suse.com/kiwi/) to learn more about creating
image recipes.

### Installation
Just clone this repo and `cd` into it. Bang! You're done.

### Build the Docker Image
```
docker build -t ims-kiwi-ng-opensuse-x86_64-builder:dev .
```

### Usage (Local Image Builds via Docker)
1. Make a directory for your Kiwi image recipe and populate it:
```
# mkdir -p /path/to/recipe
# cp -r /my/recipe/* /path/to/recipe
```
2. Make a directory to hold the build root generated by Kiwi
```
# mkdir -p /path/to/build-root
```
3. Run the container to build the image root using the directories you created
   above as volumes. This step will take a while and depending on the image
   recipe will consume considerable memory and disk space.
```
# docker run --privileged=true --rm -v /path/to/recipe:/mnt/recipe -v /path/to/build-root:/mnt/image ims-kiwi-ng-opensuse-x86_64-builder:dev
[ INFO    ]: 22:02:20 | Loading XML description
[ INFO    ]: 22:02:20 | --> loaded /mnt/recipe/config.xml
[ INFO    ]: 22:02:20 | --> Selected build type: oem
[ INFO    ]: 22:02:20 | Preparing new root system
[ INFO    ]: 22:02:20 | Setup root directory: /mnt/build-root/build/image-root
[ INFO    ]: 22:02:21 | Setting up repository obs://Virtualization:Appliances:Builder/SLE_12_SP3

...
[ INFO    ]: 22:25:07 | Result files:
[ INFO    ]: 22:25:07 | --> disk_image: /mnt/build-root/my-image.x86_64-1.0.0.raw
[ INFO    ]: 22:25:07 | --> image_packages: /mnt/build-root/my-image.x86_64-1.0.0.packages
[ INFO    ]: 22:25:07 | --> image_verified: /mnt/build-root/my-image.x86_64-1.0.0.verified
```
The resulting image (raw format) will be in `/path/to/build-root/` on your host
system. The image root will be in `path/to/build-root/build/image-root/`.

## Deployment
This Docker image will be deployed as part of the Shasta management plane
stack via Kubernetes, specifically as a part of the Image Management Service.

## Development
Development on this repository should follow the standard CMS development
[process](https://connect.us.cray.com/confluence/x/fFGfBQ).

### Versioning
We use [SemVer](http://semver.org/) for versioning. See the `.version` file in
the repository root for the current version. Please update that version when
making changes.

## Authors
* Eric Cozzi
* Randy Kleinman
* Add your name here if you want praise or blame later

## Copyright and License
This project is copyrighted by Hewlett Packard Enterprise Development LP and is under the MIT
license. See the [LICENSE](LICENSE) file for details.

When making any modifications to a file that has a Cray/HPE copyright header, that header
must be updated to include the current year.

When creating any new files in this repo, if they contain source code, they must have
the HPE copyright and license text in their header, unless the file is covered under
someone else's copyright/license (in which case that should be in the header). For this
purpose, source code files include Dockerfiles, Ansible files, RPM spec files, and shell
scripts. It does **not** include Jenkinsfiles, OpenAPI/Swagger specs, or READMEs.

When in doubt, provided the file is not covered under someone else's copyright or license, then
it does not hurt to add ours to the header.
